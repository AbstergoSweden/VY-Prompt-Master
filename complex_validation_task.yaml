identity: "VY Schema Validation Orchestrator"
purpose: "Create a prompt bundle manifest and JSON schema, validate them via iTerm2, and generate a verification report without modifying existing files."
context:
  platform: "VY (Vercept) automation agent on macOS"
  access_method: "desktop"
  auth_state: "user_logged_in_as_needed"
  environment: "macOS, iTerm2, local filesystem"
inputs:
  - name: "workspace_root"
    required: true
    description: "Absolute path to the workspace root where output will be created."
    example: "~/Desktop/VY Prompt master"
  - name: "output_folder_prefix"
    required: true
    description: "Relative folder prefix under workspace_root for the demo output."
    example: "codex-review_files/complex_validation_demo"
  - name: "bundle_id"
    required: true
    description: "Identifier for the prompt bundle manifest."
    example: "vy_prompt_bundle_demo"
task:
  goal: "Create a timestamped output folder containing a schema, manifest, validator script, validation log, and report, then verify the manifest via iTerm2."
  steps:
    - step_id: "step_001_open_iterm2"
      intent: "Open iTerm2."
      locate: "iTerm2 icon in the Dock or Applications folder."
      confirm_target: "The icon label reads 'iTerm2'."
      act: "Click the iTerm2 icon or use open_application with name 'iTerm2'."
      verify_outcome: "An iTerm2 window opens with a shell prompt."
      fallback_paths:
        - "Use Spotlight (Command+Space), type iTerm2, press Return."
      safety_gate: "safe"

    - step_id: "step_002_confirm_prompt"
      intent: "Ensure the shell prompt is active."
      locate: "Blinking cursor at the end of the prompt line."
      confirm_target: "The cursor is visible and ready for input."
      act: "Click inside the terminal and press Return to create a fresh prompt line."
      verify_outcome: "A new prompt line appears with a blinking cursor."
      fallback_paths:
        - "Open a new tab with Command+N and confirm the prompt."
      safety_gate: "safe"

    - step_id: "step_003_navigate_workspace"
      intent: "Navigate to the workspace root."
      locate: "iTerm2 prompt line."
      confirm_target: "Cursor is at a new prompt line."
      act: "Run: cd \"<workspace_root>\" && pwd"
      verify_outcome: "The printed path matches workspace_root."
      fallback_paths:
        - "Run: ls to verify the expected files before proceeding."
      safety_gate: "safe"

    - step_id: "step_004_create_output_dir"
      intent: "Create a new timestamped output directory."
      locate: "iTerm2 prompt line."
      confirm_target: "Cursor is ready for input."
      act: |
        Run:
        TS=$(date +"%Y%m%d_%H%M%S")
        OUTDIR="<output_folder_prefix>_${TS}"
        mkdir -p "$OUTDIR"
        echo "$OUTDIR"
      verify_outcome: "The output directory path is printed and the directory exists."
      fallback_paths:
        - "If date fails, use TS=manual_001 and retry mkdir."
      safety_gate: "safe"

    - step_id: "step_005_enter_output_dir"
      intent: "Move into the new output directory."
      locate: "iTerm2 prompt line."
      confirm_target: "Cursor is ready for input."
      act: "Run: cd \"$OUTDIR\" && pwd"
      verify_outcome: "The printed path ends with the new output directory."
      fallback_paths:
        - "Re-run the TS and OUTDIR assignment from step_004, then cd again."
      safety_gate: "safe"

    - step_id: "step_006_write_schema"
      intent: "Create the JSON schema for the prompt bundle manifest."
      locate: "iTerm2 prompt line in the output directory."
      confirm_target: "pwd shows the output directory."
      act: |
        Run:
        cat > "prompt_bundle.schema.json" <<'EOF'
        {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "title": "Prompt Bundle Manifest",
          "type": "object",
          "required": ["bundle_id", "version", "created_at", "description", "prompts", "validation"],
          "properties": {
            "bundle_id": {
              "type": "string",
              "pattern": "^[a-z][a-z0-9_-]+$"
            },
            "version": {
              "type": "string",
              "pattern": "^\\d+\\.\\d+\\.\\d+$"
            },
            "created_at": {
              "type": "string"
            },
            "description": {
              "type": "string"
            },
            "prompts": {
              "type": "array",
              "minItems": 1,
              "items": {
                "type": "object",
                "required": ["prompt_id", "purpose", "inputs", "output_format", "files", "safety"],
                "properties": {
                  "prompt_id": {
                    "type": "string",
                    "pattern": "^prompt_\\d{3}_[a-z0-9_]+$"
                  },
                  "purpose": { "type": "string" },
                  "inputs": { "type": "array", "items": { "type": "string" } },
                  "output_format": {
                    "type": "string",
                    "enum": ["yaml", "markdown", "plaintext"]
                  },
                  "files": {
                    "type": "array",
                    "items": { "type": "string" },
                    "minItems": 1
                  },
                  "safety": {
                    "type": "object",
                    "required": ["risk_level", "requires_confirmation"],
                    "properties": {
                      "risk_level": { "type": "string", "enum": ["safe", "caution"] },
                      "requires_confirmation": { "type": "boolean" }
                    },
                    "additionalProperties": false
                  }
                },
                "additionalProperties": false
              }
            },
            "validation": {
              "type": "object",
              "required": ["rules"],
              "properties": {
                "rules": { "type": "array", "items": { "type": "string" }, "minItems": 1 }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        }
        EOF
      verify_outcome: "prompt_bundle.schema.json exists and is non-empty."
      fallback_paths:
        - "If the here-doc fails, create the file with a text editor in the output directory."
      safety_gate: "safe"

    - step_id: "step_007_write_manifest_yaml"
      intent: "Create the YAML manifest (JSON-compatible YAML)."
      locate: "iTerm2 prompt line in the output directory."
      confirm_target: "pwd shows the output directory."
      act: |
        Run:
        cat > "prompt_bundle.yaml" <<'EOF'
        {
          "bundle_id": "<bundle_id>",
          "version": "1.0.0",
          "created_at": "2026-01-16T12:00:00Z",
          "description": "Demo prompt bundle for schema validation.",
          "prompts": [
            {
              "prompt_id": "prompt_001_headline_capture",
              "purpose": "Capture a website headline in Safari.",
              "inputs": ["url"],
              "output_format": "yaml",
              "files": ["prompt_001.yaml"],
              "safety": { "risk_level": "safe", "requires_confirmation": false }
            },
            {
              "prompt_id": "prompt_002_cookie_audit",
              "purpose": "Audit cookie settings without deletion.",
              "inputs": ["browser_name"],
              "output_format": "markdown",
              "files": ["prompt_002.yaml"],
              "safety": { "risk_level": "caution", "requires_confirmation": false }
            }
          ],
          "validation": {
            "rules": [
              "Required keys present",
              "Every prompt has at least one file",
              "Output format is one of: yaml, markdown, plaintext"
            ]
          }
        }
        EOF
      verify_outcome: "prompt_bundle.yaml exists and is non-empty."
      fallback_paths:
        - "If the here-doc fails, create the file with a text editor in the output directory."
      safety_gate: "safe"

    - step_id: "step_008_write_validator_script"
      intent: "Create a local validator script that checks required keys and patterns."
      locate: "iTerm2 prompt line in the output directory."
      confirm_target: "pwd shows the output directory."
      act: |
        Run:
        cat > "validate_bundle.py" <<'EOF'
        import json
        import re
        import sys

        def read_json(path):
          with open(path, "r", encoding="utf-8") as f:
            return json.load(f)

        def type_ok(value, schema_type):
          if schema_type == "string":
            return isinstance(value, str)
          if schema_type == "array":
            return isinstance(value, list)
          if schema_type == "object":
            return isinstance(value, dict)
          if schema_type == "boolean":
            return isinstance(value, bool)
          if schema_type == "number":
            return isinstance(value, (int, float))
          return True

        def main():
          if len(sys.argv) != 3:
            print("Usage: validate_bundle.py <manifest_path> <schema_path>")
            return 2

          manifest_path = sys.argv[1]
          schema_path = sys.argv[2]

          errors = []
          schema = read_json(schema_path)
          data = read_json(manifest_path)

          required = schema.get("required", [])
          props = schema.get("properties", {})

          for key in required:
            if key not in data:
              errors.append(f"Missing required key: {key}")

          for key in required:
            if key in data and key in props and "type" in props[key]:
              if not type_ok(data[key], props[key]["type"]):
                errors.append(f"Type mismatch for {key}: expected {props[key]['type']}")

          if "bundle_id" in data and not re.match(r"^[a-z][a-z0-9_-]+$", data["bundle_id"]):
            errors.append("bundle_id does not match required pattern")

          if "version" in data and not re.match(r"^\\d+\\.\\d+\\.\\d+$", data["version"]):
            errors.append("version does not match semver pattern")

          prompts = data.get("prompts", [])
          if not isinstance(prompts, list) or len(prompts) == 0:
            errors.append("prompts must be a non-empty array")

          for idx, p in enumerate(prompts):
            if not isinstance(p, dict):
              errors.append(f"prompt[{idx}] is not an object")
              continue
            pid = p.get("prompt_id", "")
            if not re.match(r"^prompt_\\d{3}_[a-z0-9_]+$", pid):
              errors.append(f"prompt[{idx}] prompt_id is invalid")
            ofmt = p.get("output_format", "")
            if ofmt not in ["yaml", "markdown", "plaintext"]:
              errors.append(f"prompt[{idx}] output_format is invalid")
            files = p.get("files", [])
            if not isinstance(files, list) or len(files) == 0:
              errors.append(f"prompt[{idx}] files must be a non-empty array")

          if errors:
            print("VALIDATION: FAIL")
            for e in errors:
              print(f"- {e}")
            return 1

          print("VALIDATION: PASS")
          print(f"bundle_id: {data.get('bundle_id')}")
          print(f"version: {data.get('version')}")
          print(f"prompts: {len(prompts)}")
          return 0

        if __name__ == "__main__":
          sys.exit(main())
        EOF
      verify_outcome: "validate_bundle.py exists and is non-empty."
      fallback_paths:
        - "If the here-doc fails, create the file with a text editor in the output directory."
      safety_gate: "safe"

    - step_id: "step_009_run_validation"
      intent: "Run the validator in iTerm2 and capture output."
      locate: "iTerm2 prompt line in the output directory."
      confirm_target: "prompt_bundle.yaml, prompt_bundle.schema.json, and validate_bundle.py are present."
      act: |
        Run:
        python3 "validate_bundle.py" "prompt_bundle.yaml" "prompt_bundle.schema.json" | tee "validation_log.txt"
      verify_outcome: "validation_log.txt contains VALIDATION: PASS."
      fallback_paths:
        - "If python3 is missing, run: python \"validate_bundle.py\" \"prompt_bundle.yaml\" \"prompt_bundle.schema.json\""
      safety_gate: "safe"

    - step_id: "step_010_generate_report"
      intent: "Create a report that captures files, hashes, and validator output."
      locate: "iTerm2 prompt line in the output directory."
      confirm_target: "validation_log.txt exists and contains output."
      act: |
        Run:
        {
          echo "# Validation Report"
          echo ""
          echo "## Output Directory"
          pwd
          echo ""
          echo "## Files"
          ls -1
          echo ""
          echo "## Hashes"
          shasum -a 256 "prompt_bundle.schema.json" "prompt_bundle.yaml" "validate_bundle.py"
          echo ""
          echo "## Validator Output"
          cat "validation_log.txt"
        } > "validation_report.md"
      verify_outcome: "validation_report.md exists and includes hashes and validator output."
      fallback_paths:
        - "If shasum is unavailable, use: openssl dgst -sha256 <file> for each file."
      safety_gate: "safe"

    - step_id: "step_011_final_verification"
      intent: "Confirm all expected files are present."
      locate: "iTerm2 prompt line in the output directory."
      confirm_target: "Output directory is still the current working directory."
      act: "Run: ls -1"
      verify_outcome: "The directory lists prompt_bundle.schema.json, prompt_bundle.yaml, validate_bundle.py, validation_log.txt, and validation_report.md."
      fallback_paths:
        - "Run: find . -maxdepth 1 -type f to list files explicitly."
      safety_gate: "safe"

    - step_id: "step_012_report_summary"
      intent: "Summarize results to the user."
      locate: "Not applicable."
      confirm_target: "Not applicable."
      act: "Return a summary with status, output directory path, and the report filename."
      verify_outcome: "User receives the summary and knows where the report is."
      fallback_paths: []
      safety_gate: "safe"

constraints:
  - "Do not delete or overwrite existing files."
  - "Create a new timestamped output directory; if it already exists, use a new timestamp."
  - "No network access, no package installs, and no external dependencies."
  - "Only create files inside the new output directory."
  - "Do not modify files outside the output directory."
  - "Keep all outputs ASCII and deterministic."

assumptions:
  - id: "iterm2_installed"
    statement: "iTerm2 is installed and can be opened."
    confidence: "medium"
    risk: "Unable to open iTerm2."
    mitigation: "Use the built-in Terminal app as a fallback."
    verification_method: "iTerm2 window appears with a prompt."
  - id: "workspace_writable"
    statement: "workspace_root exists and is writable."
    confidence: "high"
    risk: "Directory creation fails."
    mitigation: "Confirm the path and permissions, then stop if blocked."
    verification_method: "mkdir succeeds without errors."
  - id: "python_available"
    statement: "python3 or python is available for running the validator."
    confidence: "medium"
    risk: "Validation cannot run."
    mitigation: "Use python if python3 is missing, otherwise report and stop."
    verification_method: "Validator prints VALIDATION: PASS."

output_format:
  type: "yaml"
  structure: "Report with status, output_dir, files_created, validation_result, and report_filename."

robustness_improvements:
  retries:
    - condition: "Command returns a non-zero exit code."
      max_attempts: 2
      backoff: "250ms, then 500ms"
      recovery_action: "Re-run the command after confirming the working directory."
  rollbacks:
    - trigger: "Validation fails or required files are missing."
      procedure: "Stop and report the failure; do not delete any files."
      reversibility_level: "no_destructive_actions_taken"
  monitoring:
    - checkpoint: "step_009_run_validation"
      evidence: "validation_log.txt shows VALIDATION: PASS."
      summary_point: "Schema and manifest validated successfully."

validation_tests:
  schema_tests:
    - "prompt_bundle.schema.json contains required keys and no additionalProperties."
  ui_tests:
    - "Every step includes locate and verify_outcome."
  safety_tests:
    - "No irreversible actions are present."

self_check:
  - "All required top-level keys are present."
  - "Every step uses locate -> confirm_target -> act -> verify_outcome."
  - "No destructive actions or overwrites are included."
  - "Output directory is new and isolated."
  - "Validation output is captured in validation_log.txt and summarized."
